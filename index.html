<!DOCTYPE html>
<html>

<head>
    <script type="application/javascript" src="js/delaunay.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
    <script type="application/javascript" src="js/jquery.auto-grow-input.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300">
    <link rel="stylesheet" href="style.css">

    <script>
        var canvas;

        // Avoids redrawing when the window is being resized
        function debounce(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this, args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        }

        /* Generates a random uniform set of points and compute the Delaunay triangulation */
        function redrawDT() {

            // Obtain the number of points to draw from the input box
            var numPoints = parseInt(document.getElementById("numberOfPoints").value);
            if(isNaN(numPoints) || numPoints < 2)
                numPoints = 500;

            // It might take a while for a big number of points. Better notify the user
            if(numPoints >= 15000) {
                $("#redrawButton").prop('disabled', true);
                $("#redrawButton").text("Regenerating...");
            }

            // Allow some time (50ms) to update the UI
            setTimeout(function(){

                var header = document.getElementById("header");
                canvas.width = window.innerWidth - 60;
                canvas.height = window.innerHeight - 100 - header.offsetHeight;

                // We will not render the Delaunay triangulation for more than 100000 points.
                var render = numPoints <= 100000;
                if(!render) {
                    $(".careful").css("opacity", 1);
                    $(canvas).css("opacity", 0.1);
                } else {
                    $(".careful").css("opacity", 0);
                    $(canvas).css("opacity", 1);
                }

                // Generate random points
                var pts = [];
                for (var i = Math.floor(numPoints); i >= 0; i--)
                    // Multiply the points by a constant factor to avoid numerical imprecision
                    pts.push([(5 + Math.random() * (canvas.width - 10)) * 100, (5 + Math.random() * (canvas.height - 10)) * 100]);

                // Execute and time the Delaunay triangulation algorithm
                var start = new Date().getTime();
                var d = new Delaunay(pts);
                var faces = d.triangulate();
                var end = new Date().getTime();

                // Output performance results to console and UI
                var time = (end - start) / 1000.0;
                // Show the first two non-zero decimals
                $("#regenTime").text("Generated in " + Math.max(0.000001, time.toFixed(Math.min(20,1-Math.floor(Math.log(time)/Math.log(10))))) + "s");
                console.log("In time: " + (end - start) / 1000.0);

                // Render the triangulation
                if(render) {
                    var ctx = canvas.getContext("2d");
                    ctx.beginPath();
                    ctx.strokeStyle = "#444444";
                    ctx.lineWidth = 1;
                    ctx.lineCap="round";
                    for (i = 0; i < faces.length; i += 3) {
                        // Drawn upside down
                        ctx.moveTo(faces[i][0] / 100,       faces[i][1] / 100);
                        ctx.lineTo(faces[i + 1][0] / 100,   faces[i + 1][1] / 100);
                        ctx.lineTo(faces[i + 2][0] / 100,   faces[i + 2][1] / 100);
                        ctx.lineTo(faces[i][0] / 100,       faces[i][1] / 100);

                    }
                    ctx.stroke();
                }

                // Renable Regenerate button
                $("#redrawButton").prop('disabled', false);
                $("#redrawButton").text("Regenerate");

            }, 50);

        }

        /* Creates the canvas */
        window.onload = function(){
            canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            $("#numberOfPoints").autoGrowInput({comfortZone:0});
            $("#numberOfPoints").focus();
            $("#redrawButton").on("click", redrawDT);
            redrawDT();
        };

        window.addEventListener('resize', debounce(redrawDT, 250));
    </script>
</head>

<body>
    <h1 id="header">
        A Delaunay triangulation with
        <input id="numberOfPoints" placeholder="500">
        points.
        <button id="redrawButton">Regenerate</button>
        <span id="regenTime"></span>
    </h1>
    <div class="careful">
        <div class="title">You're a risk-taker!</div>
        But that's just too many points to render. You can still see the processing time at the top.
    </div>
</body>
</html>